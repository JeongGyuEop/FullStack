
/*
 *  예제 . 비트 논리 연산자 사용
 */

public class BitLogicExample {

	public static void main(String[] args) {
		System.out.println("45 & 25 = " + (45 & 25));
		/*
		 * 45와 25를 비트 논리곱 & 연산 해보자
		 * 
		 * 45를 2진수로 표현하면 00101101
		 * 25를 2진수로 표현하면 00011001
		 * 
		 * 00101101
		 * 00011001
		 * --------   &
		 * 00001001
		 * 
		 * 		1 X 2의 3승    -> 8
		 * 						  +  -> 9
		 * 		1 X 2의 0승    -> 1
		 * 
		 */
		
		
		// 45와 25의 논리합 | 연산
		System.out.println("45 | 25 = " + (45 | 25));
		/*
		 * 45와 25를 비트 논리합 | 연산 해보자
		 * 
		 * 45를 2진수로 표현하면 00101101
		 * 25를 2진수로 표현하면 00011001
		 * 
		 * 00101101
		 * 00011001
		 * --------   |
		 * 00111101  --> 61
		 * 
		 * 		1 X 2의 5승  -> 32
		 * 		1 X 2의 4승  -> 16
		 * 		1 X 2의 3승  ->  8
		 * 		1 X 2의 2승  ->  4
		 * 		1 X 2의 0승  ->  1
		 * 					---------  +
		 * 						61
		 * 
		 */
		
		
		// 45 비트 논리 부정 연산 ~ 해보자
		System.out.println("~45 = " + (~45)); // -46
		/*
		 * 45와 25를 비트 논리 부정 ~ 연산 해보자
		 * 
		 * 45를 2진수로 표현하면 00101101
		 * 
		 * 00101101
		 * --------    ~
		 * 11010010  <- 최상위 비트자리의 값이 1이면 음수 이므로 -46
		 * 
		 */
		
		System.out.println("-------------------------------------");
		
		/*
		 *   비트 논리 연산자들을 사용해 비트 논리연산이 왜 필요한지 예를 하나 들어보자
		 *   
		 *   	c언어로 남든 프로그램에서 외부 서버에 저장된 JAVA 언어로 만든 프로그램으로
		 *   	데이터를 전달한다고 가정하자.
		 *   
		 *   	C언어에는 unit8_t 라는 타입이 있는데,
		 *   	이 타입은 1byte 크기를 가지면서 0~255사이의 값을 컴퓨터
		 *  	변수 메모리에 저장할 수 있다.
		 *  
		 *  	반면 JAVA언어에는 nuit8_t라는 타입이 없고 대신 byte 타입이 있다.
		 *  	JAVA에서 byte 타입으로 변수를 만들어 저장할 값의 허용 범위는 -128 ~ 127 사이의 값이다.
		 *  
		 *  	C언어로 만든 프로그램이 unit8_t 타입 136값을
		 *  	java 언어로 만든 프로그램으로 전달 시 2진수로 보내면 Java 언어로 만든 프로그램에서는
		 *  	2진수를 -120으로 읽게 된다.
		 *  
		 *  	그림
		 *  		c언어에서 unit8_t 타입의 136을 2진수로 변호나 --> 10001000 후
		 *  		java언어에서 byte 타입의 1byte 크기의 변수메모리에 저장하려고 할때
		 *  		10001000은 -120으로 저장된다.
		 *  
		 *  		-120을 C언어로 만든 프로그램이 보낸 136으로 복원하고 싶다면
		 *  		-120rhk 255를 비트 논리곱(&) 연산을 수행하면 된다.
		 */
		
		byte receiveData = -120;
		/*
		 *    1byte = 8bit
		 *    4byte = 32bit 이므로 총 32칸에 2진수가 저장된다고 가정한다.
		 *    
		 *    byte receiveData 변수에 저장된 -120은 255와 비트 논리곱 & 연산 전에
		 *    아래와 같이 int 타입의 2진수로 바뀐 후 컴퓨터 변수 메모리에 저장하게 된다.
		 *    
		 *    	1byte 		1byte		1byte		1byte
		 *     11111111    11111111    11111111    10001000    (-120)
		 *     00000000	   00000000    00000000    11111111    (255)
		 *     -------------------------------------------------------
		 *     00000000	   00000000    00000000    10001000
		 *    
		 *    
		 * 
		 */
		
		// 방법 1. 비트 논리곱 연산 &로 복원값 136 얻기
		int unsignedInt1 = receiveData & 255;
		System.out.println(unsignedInt1); // 136
		
		
		
		
		
		
		
		
		
		
		
		
		
		

	}

}
