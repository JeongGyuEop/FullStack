<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      // 주제 : 배열 생성 및 요소 접근

      //fruits라는 배열 참조변수를 선언하고,
      //"Apple","Banana","Cherry"라는 세개의 문자열을 요소로 가지는 배열을 할당합니다
      let fruits = ['Apple', 'Banana', 'Cherry'];
      //              0         1        2      index

      //fruits배열의 첫 번째 요소인 "Apple"을 얻어와 출력합니다.
      console.log(fruits[0]);

      //fruits배열에 저장된 요소의 총 갯수를 얻어 출력합니다.
      console.log(fruits.length);

      //let fruits = ["Apple","Banana","Cherry"];
      //              0         1        2      index

      //배열에서 제공해주는 메소드 이용!!!!

      //배열 메모리의 가장 마지막 index2위치 뒤에 "Date"요소 추가
      fruits.push('Date'); // ["Apple","Banana","Cherry", "Date"];
      //   0        1        2        3    index

      //배열 메모리의 가장 마지막 index3위치의 "Date"요소를 제거하고 그값을 반환해오자
      let value2 = fruits.pop(); //[  "Apple","Banana","Cherry" ];
      //     0        1        2        index
      //반환한 "Date"요소를 출력
      console.log(value2); //"Date"

      //그리고 다시 fruits배열의 변화된 모습 출력!
      console.log(fruits); // [  "Apple","Banana","Cherry" ];
      //      0        1        2        index

      //배열 메모리의 가장 첫번째 저장된 "Apple"요소를 제거하고 그 값을 반환해오자
      //반환한 "Apple"요소를 출력
      //그리고 다시 fruits배열의 변화된 모습 출력!
      console.log(fruits.shift()); //"Apple"
      console.log(fruits); //['Banana', 'Cherry']
      //  0          1        index

      //배열 메모리의 0index위치 앞에(가장 앞위치에) "Avocado"를 추가합니다.
      //그리고 다시 fruits배열의 변화된 모습 출력!
      fruits.unshift('Avocado'); // ["Avocado", 'Banana', 'Cherry']
      //                                   0        1          2        index
      console.log(fruits);

      //  let fruits = ["Avocado", 'Banana', 'Cherry'];   <-현재 배열 모습
      //                     0        1          2      index

      // 반복 메소드 사용!
      //fruits배열 메모리에 저장된 각 요소를 차례대로 반복해서 얻어 출력!
      //단! forEach메소드 사용!

      //형태1. fruits.forEach(function(fruit){console.log(fruit);  });

      //형태2.
      //이 경우 각 요소를 console.log로 출력하므로
      // "Avocado", "Banana", "Cherry"
      fruits.forEach(fruit => console.log(fruit));
      //  let fruits = ["Avocado", 'Banana', 'Cherry'];   <-현재 배열 모습
      //                     0        1          2      index

      document.write('<br>');
      //-----------------------------------------------------------------------------
      // 반복 메서드 2
      // map() 메서드
      //   - 배열의 각 요소에 대해 주어진 콜백함수를 호출하고, 그 결과로 새로운 배열을
      //     생성해서 새로운 배열 자체를 반환하는 메소드
      //   - 이 메소드는 배열에 저장된 원본데이터를 변경하지 않고 계산에 의해 새로운
      //     배열에 넣어 새로운 배열 자체를 반환

      //let fruits = ['Avocado', 'Banana', 'Cherry'];
      //                 0         1         2         index

      const upperFruits = fruits.map(fruit => {
        return fruit.toUpperCase();
      });
      document.write(upperFruits, '<br>'); // 새로운 배열 생성 -> ["AVOCADO", "BANANA", "CHERRY"]
      document.write(fruits, '<br>');

      document.write('<br>');
      let upperFruits2 = fruits.map(fruit => fruit.toUpperCase());
      console.log(upperFruits2);
      document.write(upperFruits2, '<br>'); // 새로운 배열 생성 -> ["AVOCADO", "BANANA", "CHERRY"]

      //------- map() 메서드 보충
      let numbers = [1, 2, 3, 4, 5];
      //             0  1  2  3  4   index

      // numbers 배열 메모리에 저장되어 있는 모든 요소를 차례로 반복해서 얻어
      // 1요소 -> 1*1 -> 1      새로운 배열 자동생성 [1]
      // 2요소 -> 2*2 -> 4                           [1, 4]
      // 3요소 -> 3*3 -> 9                           [1, 4, 9]
      // 4요소 -> 4*4 -> 16                          [1, 4, 9, 16]
      // 5요소 -> 5*5 -> 25                          [1, 4, 9, 16, 25]
      //                                             return
      const arr = numbers.map(element => element * element);
      const arr2 = numbers.map(element => {
        return element * element;
      });
      document.write('<br>', arr, '<br>');
      document.write(arr2, '<br>');

      document.write('<br>');
      // 일반 for문을 사용하여 newNumbers배열에 저장된 요소들을 각각 차례로 얻어 출력
      for (let i = 0; i < arr.length; i++) {
        document.write(arr[i], '<br>');
      }

      //----------------------------------------------------------------------------------------
      let numbers2 = [1, 2, 3];
      let context = { value: 'Hello' };
      let newNumber2 = numbers2.map(function (number) {
        return this.value;
      }, context); // map 메서드의 두 번째 인자로 특정 객체의 속성값들을 얻어
      // 새로운 배열에 담아 새로운 배열을 반환할 수 있다.

      console.log(newNumber2);

      //      - numbers2 배열 정의
      //            let numbers2 = [1, 2, 3];
      //            > numbers2라는 이름의 배열을 정의합니다. 이 배열은 세 개의 숫자 1, 2, 3을 포함합니다.

      //      - context 객체 정의
      //            let context = { value: 'Hello' };
      //            > context라는 이름의 객체를 정의합니다.
      //              이 객체는 value라는 속성을 가지고 있으며, 값은 'Hello'입니다.

      //      - map 메서드를 사용하여 numbers2 배열의 각 요소를 변환
      //           let newNumber2 = numbers2.map(function(number) {
      //                return this.value;
      //            }, context);
      //            > map 메서드를 사용하여 numbers2 배열의 각 요소를 변환합니다.
      //            > map 메서드는 배열의 각 요소에 대해 콜백 함수를 호출하고,
      //              그 결과로 새로운 배열을 만듭니다.

      //      콜백 함수는 익명 함수로 정의되어 있으며, number라는 매개변수를 가집니다.
      //      콜백 함수 내에서 this는 context 객체를 참조합니다. 이는 map 메서드의 두 번째
      //      인수로 context 객체를 전달했기 때문입니다.
      //      콜백 함수는 this.value를 반환합니다. 여기서 this는 context 객체를 참조하므로, this.value는 'Hello'입니다.
      //      따라서 map 메서드는 numbers2 배열의 각 요소에 대해 콜백 함수를 호출하여 'Hello'를 반환하고,
      //      그 결과 새로운 배열 newNumber2는 ["Hello", "Hello", "Hello"]가 됩니다.

      //--------------------------------------------------------------------------------------------

      //let fruits = ['Avocado', 'Banana', 'Cherry'];
      //                 0         1         2         index

      // 배열 객체가 제공하는 find()메소드
      // 배열의 요소 중 조건을 만족하는 첫 번째 요소를 반환한다.
      // 여기서는 요소가 "B"로 시작하는 첫 번째 과일을 찾기 위해
      // fruit.startWith("B"); 조건검사 메서드를 호출
      // "Banana"가 "B"로 시작하므로 조건을 만족하여
      // 조건에 만족한 "Banana" 문자열을 반환해 준다.
      let foundFruit = fruits.find(fruit => fruit.startsWith('B'));

      //--------------------------------------------------------------------------------------------

      document.write('<br>');
      //let fruits = ['Avocado', 'Banana', 'Cherry'];
      //                 0         1         2         index

      // 배열에 저장된 일부 요소를 추출해서 새로운 배열로 만들어 반환
      // -> slice(index) 메서드
      //    - 배열에 특정 부분을 잘라서 새로운 배열을 만들어 반환하는 메소드
      // 여기서는 index 1부터 배열의 끝 index 위치 까지의 데이터를 잘라서
      // ["Banana", "Cherry"] 자른 새로운 배열을 반환한다.
      let sliceFruit = fruits.slice(1);
      document.write(sliceFruit);
    </script>
  </body>
</html>
